#pragma kernel GenerateHeightmap
#pragma kernel GenerateBiomeMap
#pragma kernel ErodeHeightmap
#pragma kernel SmoothHeightmap
#pragma kernel CalculateNormals
#pragma kernel GenerateMesh
#pragma kernel PlaceVegetation

// --- Inputs ---
float chunkX;
float chunkY;
float chunkSize;
int resolution;
float heightMultiplier;
float noiseScale;
int octaves;
float persistence;
float lacunarity;
float seed;
float moistureNoiseScale;
float temperatureNoiseScale;

// Advanced terrain parameters
float mountainStrength;
float plainStrength;
float erosionStrength;
float domainWarpStrength;

// Post-process parameters (GPU)
float erosionTalus;
float erosionAmount;
float smoothStrength;

// --- Outputs ---
RWTexture2D<float> HeightMap; // R channel for height
RWTexture2D<float4> BiomeMap; // R=BiomeIndex, G=Moisture, B=Temp, A=Unused
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float2> UVs;
RWStructuredBuffer<float3> Normals;
RWStructuredBuffer<int> Triangles;

// Ping-pong textures for post-process
Texture2D<float> HeightMapIn;
RWTexture2D<float> HeightMapOut;

struct VegetationInstance {
    float3 position;
    float3 scale;
    float rotationY;
    int typeID; // 0=Tree, 1=Rock, 2=Grass
};
AppendStructuredBuffer<VegetationInstance> VegetationBuffer;

// --- Helper Functions ---
// --- New Noise Functions ---

// 2D Random
float2 random2(float2 p) {
    return frac(sin(float2(dot(p,float2(127.1,311.7)),dot(p,float2(269.5,183.3))))*43758.5453);
}

// 2D Noise
float random(float2 st) {
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);
    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// IQ's Voronoi Noise
float voronoi(float2 x) {
    float2 n = floor(x);
    float2 f = frac(x);
    float m = 8.0;
    for(int j=-1; j<=1; j++)
    for(int i=-1; i<=1; i++) {
        float2 g = float2(float(i),float(j));
        float2 o = random2(n + g);
        o = 0.5 + 0.5*sin(6.2831*o); // Animate? No, static for terrain
        float2 r = g + o - f;
        float d = dot(r,r);
        if( d<m ) m=d;
    }
    return m;
}

// Hybrid Multifractal - Good for mountains
float hybridMultifractal(float2 st, int oct, float H, float lac) {
    float value = 1.0;
    float signal = 0.0;
    float frequency = 1.0;
    float weight = 1.0;
    
    // 1st Octave
    signal = (1.0 - abs(noise(st) * 2.0 - 1.0));
    signal *= signal;
    value = signal;
    weight = 1.0;
    
    st *= lac;
    
    // Remaining Octaves
    for (int i = 1; i < oct; i++) {
        weight = clamp(signal * 2.0, 0.0, 1.0); // Signal from previous octave affects weight
        signal = (1.0 - abs(noise(st) * 2.0 - 1.0));
        signal *= signal;
        signal *= weight;
        
        value += signal * pow(frequency, -H);
        frequency *= lac;
        st *= lac;
    }
    return value * 0.5; // Normalize roughly
}

float fbm(float2 st, int oct, float pers, float lac) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    float maxValue = 0.0;
    for (int i = 0; i < oct; i++) {
        value += amplitude * noise(st * frequency);
        maxValue += amplitude;
        frequency *= lac;
        amplitude *= pers;
    }
    return value / maxValue;
}

// Ridged FBM - smoother mountain ranges than raw voronoi inversion
float ridgedFbm(float2 st, int oct, float pers, float lac) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    float maxValue = 0.0;
    float prev = 1.0;
    for (int i = 0; i < oct; i++) {
        float n = noise(st * frequency);
        float r = 1.0 - abs(n * 2.0 - 1.0); // ridge
        r *= r; // sharpen ridge while keeping smooth slopes
        value += r * amplitude * prev;
        maxValue += amplitude;
        prev = r;
        frequency *= lac;
        amplitude *= pers;
    }
    return value / maxValue;
}

float2 domainWarp(float2 p, float strength) {
    float2 q = float2(
        fbm(p + float2(0.0, 0.0), 4, 0.5, 2.0),
        fbm(p + float2(5.2, 1.3), 4, 0.5, 2.0)
    );
    return p + q * strength;
}

float GetHeight(float2 worldPos) {
    float2 noisePos = (worldPos + float2(seed * 100.0, seed * 100.0)) * noiseScale;

    // Domain warp: use user parameter, but scale to noise-space (defaults in inspector are in "human" range)
    float warp = domainWarpStrength * 0.25;
    float2 p = domainWarp(noisePos, warp);

    // 1) Continents / macro shape
    float continents = fbm(p * 0.10, 4, 0.5, 2.0);

    // 2) Hills (signed, subtle)
    float hills = fbm(p * 0.85, max(3, octaves - 1), persistence, lacunarity);
    float hillsSigned = (hills * 2.0 - 1.0) * 0.18; // [-0.18..0.18]

    // 3) Mountains (ridged)
    float ridges = ridgedFbm(p * 1.65, min(octaves, 6), 0.5, 2.0);

    float height01 = 0.0;

    // Ocean / beach band is kept close to old thresholds for biome consistency
    if (continents < 0.30) {
        height01 = continents * 0.80;
    } else {
        float landMask = smoothstep(0.30, 0.40, continents);
        float mtnMask = smoothstep(0.58, 0.80, continents);

        height01 = continents;
        height01 += landMask * (hillsSigned * plainStrength);
        height01 += ridges * mtnMask * mountainStrength * 0.90;
    }

    // Clamp to keep biome thresholds stable and prevent rare blow-ups into spikes
    height01 = saturate(height01);
    return height01 * heightMultiplier;
}

// Enhanced biome system
// 0=Ocean, 1=Beach, 2=Plains, 3=Grassland, 4=Forest, 5=Mountain, 6=Snow, 7=Desert
float GetBiome(float heightNorm, float moisture, float temp) {
    if (heightNorm < 0.15) return 0.0; // Ocean
    if (heightNorm < 0.22) return 1.0; // Beach
    
    if (heightNorm > 0.85) return 6.0; // Snow peaks
    if (heightNorm > 0.65) return 5.0; // Mountains
    
    // Biome based on moisture and temperature
    if (temp > 0.65 && moisture < 0.3) return 7.0; // Desert
    if (moisture > 0.65 && heightNorm < 0.5) return 4.0; // Forest
    if (moisture > 0.4) return 3.0; // Grassland
    if (heightNorm < 0.35) return 2.0; // Plains
    
    return 3.0; // Default to grassland
}

[numthreads(8, 8, 1)]
void GenerateHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    float step = chunkSize / (float)(resolution - 1);
    float2 localPos = float2(id.x * step, id.y * step);
    float2 worldPos = float2(chunkX * chunkSize, chunkY * chunkSize) + localPos;

    float height = GetHeight(worldPos);

    HeightMap[id.xy] = height;
}

[numthreads(8, 8, 1)]
void GenerateBiomeMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    float step = chunkSize / (float)(resolution - 1);
    float2 localPos = float2(id.x * step, id.y * step);
    float2 worldPos = float2(chunkX * chunkSize, chunkY * chunkSize) + localPos;

    float height = HeightMap[id.xy];

    // Moisture & Temp noise
    float moisture = fbm((worldPos + seed * 500.0) * moistureNoiseScale, 4, 0.5, 2.0);
    float temp = fbm((worldPos + seed * 800.0) * temperatureNoiseScale, 4, 0.5, 2.0);

    // Temperature varies with height (higher = colder)
    float heightNorm = height / heightMultiplier;
    temp = lerp(temp, temp * 0.3, smoothstep(0.3, 0.9, heightNorm));

    float biome = GetBiome(heightNorm, moisture, temp);
    BiomeMap[id.xy] = float4(biome, moisture, temp, 0.0);
}

[numthreads(8, 8, 1)]
void ErodeHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    int2 p = int2(id.x, id.y);

    // Use Load for Texture2D input
    float hC = HeightMapIn.Load(int3(p, 0));
    float hL = HeightMapIn.Load(int3(int2(max(p.x - 1, 0), p.y), 0));
    float hR = HeightMapIn.Load(int3(int2(min(p.x + 1, resolution - 1), p.y), 0));
    float hD = HeightMapIn.Load(int3(int2(p.x, max(p.y - 1, 0)), 0));
    float hU = HeightMapIn.Load(int3(int2(p.x, min(p.y + 1, resolution - 1)), 0));

    // Anisotropic diffusion: smooth steep slopes much more than flat areas
    float grad = max(max(abs(hC - hL), abs(hC - hR)), max(abs(hC - hD), abs(hC - hU)));
    float lap = (hL + hR + hD + hU) - 4.0 * hC;

    float mask = saturate((grad - erosionTalus) / max(erosionTalus, 1e-4));
    float hN = hC + lap * (erosionAmount * mask);

    HeightMapOut[p] = max(0.0, hN);
}

[numthreads(8, 8, 1)]
void SmoothHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    int2 p = int2(id.x, id.y);

    // 3x3 gaussian-ish blur
    float sum = 0.0;
    float wsum = 0.0;
    for (int oy = -1; oy <= 1; oy++)
    {
        for (int ox = -1; ox <= 1; ox++)
        {
            int2 q = int2(clamp(p.x + ox, 0, resolution - 1), clamp(p.y + oy, 0, resolution - 1));
            float w = (ox == 0 && oy == 0) ? 4.0 : ((ox == 0 || oy == 0) ? 2.0 : 1.0);
            sum += HeightMapIn.Load(int3(q, 0)) * w;
            wsum += w;
        }
    }
    float blurred = sum / wsum;
    float hC = HeightMapIn.Load(int3(p, 0));
    HeightMapOut[p] = lerp(hC, blurred, saturate(smoothStrength));
}

[numthreads(8, 8, 1)]
void CalculateNormals (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Finite difference method for normals from HeightMap
    float step = chunkSize / (float)(resolution - 1);
    float hL = HeightMap[int2(max(0, (int)id.x - 1), id.y)];
    float hR = HeightMap[int2(min(resolution - 1, (int)id.x + 1), id.y)];
    float hD = HeightMap[int2(id.x, max(0, (int)id.y - 1))];
    float hU = HeightMap[int2(id.x, min(resolution - 1, (int)id.y + 1))];
    
    float3 n = normalize(float3((hL - hR) / (2.0 * step), 2.0, (hD - hU) / (2.0 * step)));
    Normals[id.x + id.y * resolution] = n;
}


[numthreads(8, 8, 1)]
void GenerateMesh (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    int index = id.x + id.y * resolution;
    float step = chunkSize / (float)(resolution - 1);
    
    float height = HeightMap[id.xy];
    
    Vertices[index] = float3(id.x * step, height, id.y * step);
    UVs[index] = float2(id.x / (float)(resolution - 1), id.y / (float)(resolution - 1));
    
    // Generate Triangles (only for x < res-1 and y < res-1)
    if (id.x < (uint)(resolution - 1) && id.y < (uint)(resolution - 1)) {
        int triIndex = (id.x + id.y * (resolution - 1)) * 6;
        
        Triangles[triIndex] = index;
        Triangles[triIndex + 1] = index + resolution;
        Triangles[triIndex + 2] = index + 1;
        
        Triangles[triIndex + 3] = index + 1;
        Triangles[triIndex + 4] = index + resolution;
        Triangles[triIndex + 5] = index + resolution + 1;
    }
}

[numthreads(8, 8, 1)]
void PlaceVegetation (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Read cached values
    float height = HeightMap[id.xy];
    float4 biomeData = BiomeMap[id.xy];
    float biome = biomeData.x;
    float moisture = biomeData.y;
    
    // Random check
    float2 worldPos = float2(chunkX * chunkSize + id.x * (chunkSize/resolution), chunkY * chunkSize + id.y * (chunkSize/resolution));
    float rng = random(worldPos * 1.23); // New random seed per pos
    
    float heightNorm = height / heightMultiplier;
    float slope = 1.0 - Normals[id.x + id.y * resolution].y;

    if (heightNorm < 0.22) return; // Underwater/Beach
    if (slope > 0.45) return; // Too steep

    // Spawning logic
    VegetationInstance inst;
    inst.position = Vertices[id.x + id.y * resolution];
    inst.scale = float3(1, 1, 1) * (0.8 + rng * 0.4);
    inst.rotationY = rng * 360.0;
    
    // Forest: Trees
    if (biome == 4.0) { // Forest
        if (rng > 0.97) { // 3% chance per vertex
             inst.typeID = 0; // Tree
             VegetationBuffer.Append(inst);
             return;
        }
    }
    
    // Grassland: Some trees and grass
    if (biome == 3.0) {
        if (rng > 0.995) { // 0.5% chance for trees
            inst.typeID = 0; // Tree
            VegetationBuffer.Append(inst);
            return;
        }
    }
    
    // Everywhere suitable: Grass
    if (biome == 2.0 || biome == 3.0 || biome == 4.0) { // Plains, Grassland, Forest
        if (rng > 0.75 && rng < 0.92) { // 17% chance
            inst.typeID = 2; // Grass
            // Slightly randomize position off-grid
            inst.position.x += (rng - 0.5) * 2.0;
            inst.position.z += (random(worldPos*2.0) - 0.5) * 2.0;
            VegetationBuffer.Append(inst);
        }
    }
    
    // Mountains: Rocks
    if (biome == 5.0 || biome == 6.0 || slope > 0.25) { // Mountain, Snow, or steep
         if (rng > 0.98) { // 2% chance
             inst.typeID = 1; // Rock
             inst.scale = float3(1, 1, 1) * (0.5 + rng * 1.0); // Vary rock size more
             VegetationBuffer.Append(inst);
         }
    }
}
