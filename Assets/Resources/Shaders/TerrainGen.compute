#pragma kernel GenerateHeightmap
#pragma kernel CalculateNormals
#pragma kernel GenerateMesh
#pragma kernel PlaceVegetation

// --- Inputs ---
float chunkX;
float chunkY;
float chunkSize;
int resolution;
float heightMultiplier;
float noiseScale;
int octaves;
float persistence;
float lacunarity;
float seed;
float moistureNoiseScale;
float temperatureNoiseScale;

// --- Outputs ---
RWTexture2D<float> HeightMap; // R channel for height
RWTexture2D<float4> BiomeMap; // R=BiomeIndex, G=Moisture, B=Temp, A=Unused
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float2> UVs;
RWStructuredBuffer<float3> Normals;
RWStructuredBuffer<int> Triangles;

struct VegetationInstance {
    float3 position;
    float3 scale;
    float rotationY;
    int typeID; // 0=Tree, 1=Rock, 2=Grass
};
AppendStructuredBuffer<VegetationInstance> VegetationBuffer;

// --- Helper Functions ---
float random(float2 st) {
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);
    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(float2 st, int oct, float pers, float lac) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for (int i = 0; i < oct; i++) {
        value += amplitude * noise(st * frequency);
        st += 100.0; // Shift to avoid artifacts
        frequency *= lac;
        amplitude *= pers;
    }
    return value; // 0..1 range approx
}

float GetHeight(float2 worldPos) {
    float2 noisePos = (worldPos + float2(seed * 100.0, seed * 100.0)) * noiseScale;
    float h = fbm(noisePos, octaves, persistence, lacunarity);
    
    // Domain Warping for mountains
    float2 q = float2(
        fbm(noisePos + float2(0.0, 0.0), 4, 0.5, 2.0),
        fbm(noisePos + float2(5.2, 1.3), 4, 0.5, 2.0)
    );
    
    // Add ridge noise for mountains
    float ridge = 1.0 - abs(noise(noisePos + q * 2.0) * 2.0 - 1.0);
    h = lerp(h, ridge * h, 0.5);

    return h * heightMultiplier;
}

// 0=Ocean, 1=Beach, 2=Grass, 3=Forest, 4=Snow, 5=Desert
float GetBiome(float heightNorm, float moisture, float temp) {
    if (heightNorm < 0.2) return 0.0; // Ocean
    if (heightNorm < 0.25) return 1.0; // Beach
    
    if (heightNorm > 0.8) return 4.0; // Snow
    
    if (temp > 0.6 && moisture < 0.3) return 5.0; // Desert
    if (moisture > 0.6) return 3.0; // Forest
    
    return 2.0; // Grassland
}

[numthreads(8, 8, 1)]
void GenerateHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    float step = chunkSize / (float)(resolution - 1);
    float2 localPos = float2(id.x * step, id.y * step);
    float2 worldPos = float2(chunkX * chunkSize, chunkY * chunkSize) + localPos;

    float height = GetHeight(worldPos);
    
    // Moisture & Temp noise
    float moisture = fbm((worldPos + seed * 500.0) * moistureNoiseScale, 3, 0.5, 2.0);
    float temp = fbm((worldPos + seed * 800.0) * temperatureNoiseScale, 3, 0.5, 2.0);
    
    float heightNorm = height / heightMultiplier;
    float biome = GetBiome(heightNorm, moisture, temp);

    HeightMap[id.xy] = height;
    BiomeMap[id.xy] = float4(biome, moisture, temp, 0.0);
}

[numthreads(8, 8, 1)]
void CalculateNormals (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Finite difference method for normals from HeightMap
    float hL = HeightMap[int2(max(0, (int)id.x - 1), id.y)];
    float hR = HeightMap[int2(min(resolution - 1, (int)id.x + 1), id.y)];
    float hD = HeightMap[int2(id.x, max(0, (int)id.y - 1))];
    float hU = HeightMap[int2(id.x, min(resolution - 1, (int)id.y + 1))];
    
    float3 n = normalize(float3(hL - hR, 2.0, hD - hU)); // Simplified, assume uniform grid
    Normals[id.x + id.y * resolution] = n;
}


[numthreads(8, 8, 1)]
void GenerateMesh (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    int index = id.x + id.y * resolution;
    float step = chunkSize / (float)(resolution - 1);
    
    float height = HeightMap[id.xy];
    
    Vertices[index] = float3(id.x * step, height, id.y * step);
    UVs[index] = float2(id.x / (float)(resolution - 1), id.y / (float)(resolution - 1));
    
    // Generate Triangles (only for x < res-1 and y < res-1)
    if (id.x < (uint)(resolution - 1) && id.y < (uint)(resolution - 1)) {
        int triIndex = (id.x + id.y * (resolution - 1)) * 6;
        
        Triangles[triIndex] = index;
        Triangles[triIndex + 1] = index + resolution;
        Triangles[triIndex + 2] = index + 1;
        
        Triangles[triIndex + 3] = index + 1;
        Triangles[triIndex + 4] = index + resolution;
        Triangles[triIndex + 5] = index + resolution + 1;
    }
}

[numthreads(8, 8, 1)]
void PlaceVegetation (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Read cached values
    float height = HeightMap[id.xy];
    float4 biomeData = BiomeMap[id.xy];
    float biome = biomeData.x;
    float moisture = biomeData.y;
    
    // Random check
    float2 worldPos = float2(chunkX * chunkSize + id.x * (chunkSize/resolution), chunkY * chunkSize + id.y * (chunkSize/resolution));
    float rng = random(worldPos * 1.23); // New random seed per pos
    
    float heightNorm = height / heightMultiplier;
    float slope = 1.0 - Normals[id.x + id.y * resolution].y;

    if (heightNorm < 0.22) return; // Underwater/Beach
    if (slope > 0.4) return; // Too steep

    // Spawning logic
    VegetationInstance inst;
    inst.position = Vertices[id.x + id.y * resolution];
    inst.scale = float3(1, 1, 1) * (0.8 + rng * 0.4);
    inst.rotationY = rng * 360.0;
    
    // Forest: Trees
    if (biome == 3.0) { // Forest
        if (rng > 0.98) { // 2% chance per vertex
             inst.typeID = 0; // Tree
             VegetationBuffer.Append(inst);
             return;
        }
    }
    
    // Everywhere: Grass
    if (biome == 2.0 || biome == 3.0) {
        if (rng > 0.8 && rng < 0.95) {
            inst.typeID = 2; // Grass
            // Slightly randomize position off-grid
            inst.position.x += (rng - 0.5);
            inst.position.z += (random(worldPos*2.0) - 0.5);
            VegetationBuffer.Append(inst);
        }
    }
    
    // Mountains: Rocks
    if (biome == 4.0 || slope > 0.2) {
         if (rng > 0.99) {
             inst.typeID = 1; // Rock
             VegetationBuffer.Append(inst);
         }
    }
}
