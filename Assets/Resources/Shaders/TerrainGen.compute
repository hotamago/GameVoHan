#pragma kernel GenerateHeightmap
#pragma kernel GenerateBiomeMap
#pragma kernel ErodeHeightmap
#pragma kernel SmoothHeightmap
#pragma kernel CalculateNormals
#pragma kernel GenerateMesh

// --- Inputs ---
// 64-bit chunk coordinates (two's complement) passed as uint hi/lo parts.
// This avoids float precision issues at extreme distances.
uint chunkXLo;
uint chunkXHi;
uint chunkYLo;
uint chunkYHi;
float chunkSize;
int resolution;
float heightMultiplier;
int octaves;
float persistence;
float lacunarity;
int seed;

// Noise scale expressed as "power-of-two cell size in vertex-grid units".
// Larger shift => larger features. This stays stable forever because it uses integer math.
int baseNoiseShift;
int moistureNoiseShift;
int temperatureNoiseShift;

// Advanced terrain parameters
float mountainStrength;
float plainStrength;
float erosionStrength;
float domainWarpStrength;

// Post-process parameters (GPU)
float erosionTalus;
float erosionAmount;
float smoothStrength;

// --- Outputs ---
RWTexture2D<float> HeightMap; // R channel for height
RWTexture2D<float4> BiomeMap; // R=BiomeIndex, G=Moisture, B=Temp, A=Unused
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float2> UVs;
RWStructuredBuffer<float3> Normals;
RWStructuredBuffer<int> Triangles;

// Ping-pong textures for post-process
Texture2D<float> HeightMapIn;
RWTexture2D<float> HeightMapOut;


// --- Helper Functions ---
// --- 64-bit stable noise (no float world coords) ---
uint Hash32(uint x)
{
    x ^= x >> 16;
    x *= 0x7feb352d;
    x ^= x >> 15;
    x *= 0x846ca68b;
    x ^= x >> 16;
    return x;
}

uint HashCombine(uint h, uint v)
{
    // Simple avalanche combine
    return Hash32(h ^ (v + 0x9e3779b9u + (h << 6) + (h >> 2)));
}

float HashTo01(uint h)
{
    // 24-bit mantissa fraction
    return (float)(h & 0x00FFFFFFu) / 16777216.0;
}

uint2 AddU64(uint2 a, uint2 b)
{
    uint lo = a.x + b.x;
    uint carry = (lo < a.x) ? 1u : 0u;
    uint hi = a.y + b.y + carry;
    return uint2(lo, hi);
}

uint2 AddU64_U32(uint2 a, uint b)
{
    uint lo = a.x + b;
    uint carry = (lo < a.x) ? 1u : 0u;
    return uint2(lo, a.y + carry);
}

uint2 MulU64_U32(uint2 a, uint b)
{
    // Multiply 64-bit (hi,lo) by 32-bit b.
    // In this project, b is always small (< 2^16) because it is (resolution-1),
    // so we can compute the high 32 bits without umulExtended (better cross-platform support).
    uint aLo = a.x;
    uint aHi = a.y;

    uint a0 = aLo & 0xFFFFu;
    uint a1 = aLo >> 16;

    uint p0 = a0 * b; // <= 32 bits
    uint p1 = a1 * b; // <= 32 bits

    uint lo = p0 + (p1 << 16);
    uint carry = (lo < p0) ? 1u : 0u;

    uint hi = (p1 >> 16) + carry;
    hi += aHi * b;

    return uint2(lo, hi);
}

uint2 ShrU64(uint2 v, uint s)
{
    // In this project, shifts are clamped to [0..30] from C#
    if (s == 0) return v;
    uint lo = (v.x >> s) | (v.y << (32u - s));
    uint hi = (v.y >> s);
    return uint2(lo, hi);
}

float Hash2D64(uint2 x, uint2 y, uint salt)
{
    uint h = Hash32(salt);
    h = HashCombine(h, x.x);
    h = HashCombine(h, x.y);
    h = HashCombine(h, y.x);
    h = HashCombine(h, y.y);
    return HashTo01(h);
}

float ValueNoise64(uint2 gx, uint2 gz, int shift, uint salt)
{
    shift = max(0, min(30, shift));
    if (shift == 0)
    {
        // Cell size = 1 vertex; no interpolation possible.
        // Bias signed coords so (-1,0) is adjacent to (0,0) in integer space.
        uint2 bx = uint2(gx.x, gx.y ^ 0x80000000u);
        uint2 bz = uint2(gz.x, gz.y ^ 0x80000000u);
        return Hash2D64(bx, bz, salt);
    }

    // Bias signed coords so negative/positive coordinates are continuous across 0.
    uint2 bgx = uint2(gx.x, gx.y ^ 0x80000000u);
    uint2 bgz = uint2(gz.x, gz.y ^ 0x80000000u);

    uint mask = (1u << (uint)shift) - 1u;
    float fx = (float)(bgx.x & mask) / (float)(1u << (uint)shift);
    float fz = (float)(bgz.x & mask) / (float)(1u << (uint)shift);
    float2 f = float2(fx, fz);
    float2 u = f * f * (3.0 - 2.0 * f);

    uint2 cellX = ShrU64(bgx, (uint)shift);
    uint2 cellZ = ShrU64(bgz, (uint)shift);

    float a = Hash2D64(cellX, cellZ, salt);
    float b = Hash2D64(AddU64_U32(cellX, 1u), cellZ, salt);
    float c = Hash2D64(cellX, AddU64_U32(cellZ, 1u), salt);
    float d = Hash2D64(AddU64_U32(cellX, 1u), AddU64_U32(cellZ, 1u), salt);

    return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);
}

float Fbm64(uint2 gx, uint2 gz, int baseShift, int oct, float pers, uint saltBase)
{
    float value = 0.0;
    float amplitude = 0.5;
    float maxValue = 0.0;

    for (int i = 0; i < oct; i++)
    {
        int s = max(0, baseShift - i); // lacunarity ~= 2 by shifting
        value += amplitude * ValueNoise64(gx, gz, s, saltBase + (uint)(i * 1013));
        maxValue += amplitude;
        amplitude *= pers;
    }

    return value / max(maxValue, 1e-6);
}

float RidgedFbm64(uint2 gx, uint2 gz, int baseShift, int oct, float pers, uint saltBase)
{
    float value = 0.0;
    float amplitude = 0.5;
    float maxValue = 0.0;
    float prev = 1.0;

    for (int i = 0; i < oct; i++)
    {
        int s = max(0, baseShift - i);
        float n = ValueNoise64(gx, gz, s, saltBase + (uint)(i * 1583));
        float r = 1.0 - abs(n * 2.0 - 1.0);
        r *= r;
        value += r * amplitude * prev;
        maxValue += amplitude;
        prev = r;
        amplitude *= pers;
    }

    return value / max(maxValue, 1e-6);
}

float GetHeightFromGrid(uint2 gx, uint2 gz)
{
    // Derive stable salts from seed (seed is int, can be negative)
    uint s0 = Hash32((uint)seed ^ 0xA341316Cu);
    uint s1 = Hash32((uint)seed ^ 0xC8013EA4u);
    uint s2 = Hash32((uint)seed ^ 0xAD90777Du);

    // Continents: much larger features
    float continents = Fbm64(gx, gz, baseNoiseShift + 4, 4, 0.5, s0);

    // Hills: mid-scale signed variation
    float hills = Fbm64(gx, gz, baseNoiseShift + 1, max(3, octaves - 1), persistence, s1);
    float hillsSigned = (hills * 2.0 - 1.0) * 0.18;

    // Mountains: ridged detail
    float ridges = RidgedFbm64(gx, gz, baseNoiseShift, min(octaves, 6), 0.5, s2);

    float height01 = 0.0;

    if (continents < 0.30)
    {
        height01 = continents * 0.80;
    }
    else
    {
        float landMask = smoothstep(0.30, 0.40, continents);
        float mtnMask = smoothstep(0.58, 0.80, continents);

        height01 = continents;
        height01 += landMask * (hillsSigned * plainStrength);
        height01 += ridges * mtnMask * mountainStrength * 0.90;
    }

    height01 = saturate(height01);
    return height01 * heightMultiplier;
}

// Enhanced biome system
// 0=Ocean, 1=Beach, 2=Plains, 3=Grassland, 4=Forest, 5=Mountain, 6=Snow, 7=Desert
float GetBiome(float heightNorm, float moisture, float temp) {
    if (heightNorm < 0.15) return 0.0; // Ocean
    if (heightNorm < 0.22) return 1.0; // Beach
    
    if (heightNorm > 0.85) return 6.0; // Snow peaks
    if (heightNorm > 0.65) return 5.0; // Mountains
    
    // Biome based on moisture and temperature
    if (temp > 0.65 && moisture < 0.3) return 7.0; // Desert
    if (moisture > 0.65 && heightNorm < 0.5) return 4.0; // Forest
    if (moisture > 0.4) return 3.0; // Grassland
    if (heightNorm < 0.35) return 2.0; // Plains
    
    return 3.0; // Default to grassland
}

[numthreads(8, 8, 1)]
void GenerateHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    // Build a global *integer* vertex-grid coordinate:
    // gridX = chunkX * (resolution-1) + id.x
    // gridZ = chunkY * (resolution-1) + id.y
    uint2 chunkX64 = uint2(chunkXLo, chunkXHi);
    uint2 chunkY64 = uint2(chunkYLo, chunkYHi);
    uint vertsPerChunk = (uint)(resolution - 1);
    uint2 gx = AddU64_U32(MulU64_U32(chunkX64, vertsPerChunk), id.x);
    uint2 gz = AddU64_U32(MulU64_U32(chunkY64, vertsPerChunk), id.y);

    float height = GetHeightFromGrid(gx, gz);

    HeightMap[id.xy] = height;
}

[numthreads(8, 8, 1)]
void GenerateBiomeMap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    float height = HeightMap[id.xy];

    // Moisture & Temp noise
    uint2 chunkX64 = uint2(chunkXLo, chunkXHi);
    uint2 chunkY64 = uint2(chunkYLo, chunkYHi);
    uint vertsPerChunk = (uint)(resolution - 1);
    uint2 gx = AddU64_U32(MulU64_U32(chunkX64, vertsPerChunk), id.x);
    uint2 gz = AddU64_U32(MulU64_U32(chunkY64, vertsPerChunk), id.y);

    uint sm = Hash32((uint)seed ^ 0x3C6EF372u);
    uint st = Hash32((uint)seed ^ 0xBB67AE85u);
    float moisture = Fbm64(gx, gz, moistureNoiseShift, 4, 0.5, sm);
    float temp = Fbm64(gx, gz, temperatureNoiseShift, 4, 0.5, st);

    // Temperature varies with height (higher = colder)
    float heightNorm = height / heightMultiplier;
    temp = lerp(temp, temp * 0.3, smoothstep(0.3, 0.9, heightNorm));

    float biome = GetBiome(heightNorm, moisture, temp);
    BiomeMap[id.xy] = float4(biome, moisture, temp, 0.0);
}

[numthreads(8, 8, 1)]
void ErodeHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    int2 p = int2(id.x, id.y);

    // Use Load for Texture2D input
    float hC = HeightMapIn.Load(int3(p, 0));
    float hL = HeightMapIn.Load(int3(int2(max(p.x - 1, 0), p.y), 0));
    float hR = HeightMapIn.Load(int3(int2(min(p.x + 1, resolution - 1), p.y), 0));
    float hD = HeightMapIn.Load(int3(int2(p.x, max(p.y - 1, 0)), 0));
    float hU = HeightMapIn.Load(int3(int2(p.x, min(p.y + 1, resolution - 1)), 0));

    // Anisotropic diffusion: smooth steep slopes much more than flat areas
    float grad = max(max(abs(hC - hL), abs(hC - hR)), max(abs(hC - hD), abs(hC - hU)));
    float lap = (hL + hR + hD + hU) - 4.0 * hC;

    float mask = saturate((grad - erosionTalus) / max(erosionTalus, 1e-4));
    float hN = hC + lap * (erosionAmount * mask);

    HeightMapOut[p] = max(0.0, hN);
}

[numthreads(8, 8, 1)]
void SmoothHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    int2 p = int2(id.x, id.y);

    // 3x3 gaussian-ish blur
    float sum = 0.0;
    float wsum = 0.0;
    for (int oy = -1; oy <= 1; oy++)
    {
        for (int ox = -1; ox <= 1; ox++)
        {
            int2 q = int2(clamp(p.x + ox, 0, resolution - 1), clamp(p.y + oy, 0, resolution - 1));
            float w = (ox == 0 && oy == 0) ? 4.0 : ((ox == 0 || oy == 0) ? 2.0 : 1.0);
            sum += HeightMapIn.Load(int3(q, 0)) * w;
            wsum += w;
        }
    }
    float blurred = sum / wsum;
    float hC = HeightMapIn.Load(int3(p, 0));
    HeightMapOut[p] = lerp(hC, blurred, saturate(smoothStrength));
}

[numthreads(8, 8, 1)]
void CalculateNormals (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Finite difference method for normals from HeightMap
    float step = chunkSize / (float)(resolution - 1);
    float hL = HeightMap[int2(max(0, (int)id.x - 1), id.y)];
    float hR = HeightMap[int2(min(resolution - 1, (int)id.x + 1), id.y)];
    float hD = HeightMap[int2(id.x, max(0, (int)id.y - 1))];
    float hU = HeightMap[int2(id.x, min(resolution - 1, (int)id.y + 1))];
    
    float3 n = normalize(float3((hL - hR) / (2.0 * step), 2.0, (hD - hU) / (2.0 * step)));
    Normals[id.x + id.y * resolution] = n;
}


[numthreads(8, 8, 1)]
void GenerateMesh (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    int index = id.x + id.y * resolution;
    float step = chunkSize / (float)(resolution - 1);
    
    float height = HeightMap[id.xy];
    
    // Ensure edge vertices are exactly aligned for seamless chunks
    // For the last vertex in each dimension, use exact chunkSize to avoid rounding errors
    float localX = (id.x == (uint)(resolution - 1)) ? chunkSize : (id.x * step);
    float localZ = (id.y == (uint)(resolution - 1)) ? chunkSize : (id.y * step);
    
    Vertices[index] = float3(localX, height, localZ);
    UVs[index] = float2(id.x / (float)(resolution - 1), id.y / (float)(resolution - 1));
    
    // Generate Triangles (only for x < res-1 and y < res-1)
    if (id.x < (uint)(resolution - 1) && id.y < (uint)(resolution - 1)) {
        int triIndex = (id.x + id.y * (resolution - 1)) * 6;
        
        Triangles[triIndex] = index;
        Triangles[triIndex + 1] = index + resolution;
        Triangles[triIndex + 2] = index + 1;
        
        Triangles[triIndex + 3] = index + 1;
        Triangles[triIndex + 4] = index + resolution;
        Triangles[triIndex + 5] = index + resolution + 1;
    }
}

