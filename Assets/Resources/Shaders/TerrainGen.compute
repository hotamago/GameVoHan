#pragma kernel GenerateHeightmap
#pragma kernel CalculateNormals
#pragma kernel GenerateMesh
#pragma kernel PlaceVegetation

// --- Inputs ---
float chunkX;
float chunkY;
float chunkSize;
int resolution;
float heightMultiplier;
float noiseScale;
int octaves;
float persistence;
float lacunarity;
float seed;
float moistureNoiseScale;
float temperatureNoiseScale;

// Advanced terrain parameters
float mountainStrength;
float plainStrength;
float erosionStrength;
float domainWarpStrength;

// Multi-layer noise parameters
float macroScale;      // Large scale features
float mesoScale;       // Medium scale features
float microScale;      // Small details
float macroWeight;
float mesoWeight;
float microWeight;

// Voronoi and cellular noise
float voronoiScale;
float voronoiStrength;
float cellularScale;
float cellularStrength;

// River/valley generation
float riverStrength;
float valleyStrength;

// --- Outputs ---
RWTexture2D<float> HeightMap; // R channel for height
RWTexture2D<float4> BiomeMap; // R=BiomeIndex, G=Moisture, B=Temp, A=Unused
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float2> UVs;
RWStructuredBuffer<float3> Normals;
RWStructuredBuffer<int> Triangles;

struct VegetationInstance {
    float3 position;
    float3 scale;
    float rotationY;
    int typeID; // 0=Tree, 1=Rock, 2=Grass
};
AppendStructuredBuffer<VegetationInstance> VegetationBuffer;

// --- Helper Functions ---
float random(float2 st) {
    return frac(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

float2 random2(float2 st) {
    st = float2(dot(st, float2(127.1, 311.7)), dot(st, float2(269.5, 183.3)));
    return frac(sin(st) * 43758.5453123);
}

float noise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);
    float a = random(i);
    float b = random(i + float2(1.0, 0.0));
    float c = random(i + float2(0.0, 1.0));
    float d = random(i + float2(1.0, 1.0));
    float2 u = f * f * (3.0 - 2.0 * f); // Smoothstep
    return lerp(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// Improved Perlin-like noise with better gradients
float perlinNoise(float2 st) {
    float2 i = floor(st);
    float2 f = frac(st);
    float2 u = f * f * (3.0 - 2.0 * f);
    
    float2 grad00 = random2(i) * 2.0 - 1.0;
    float2 grad10 = random2(i + float2(1.0, 0.0)) * 2.0 - 1.0;
    float2 grad01 = random2(i + float2(0.0, 1.0)) * 2.0 - 1.0;
    float2 grad11 = random2(i + float2(1.0, 1.0)) * 2.0 - 1.0;
    
    float n00 = dot(grad00, f);
    float n10 = dot(grad10, f - float2(1.0, 0.0));
    float n01 = dot(grad01, f - float2(0.0, 1.0));
    float n11 = dot(grad11, f - float2(1.0, 1.0));
    
    return lerp(lerp(n00, n10, u.x), lerp(n01, n11, u.x), u.y) * 0.5 + 0.5;
}

// Fractional Brownian Motion - multiple octaves of noise
float fbm(float2 st, int oct, float pers, float lac) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for (int i = 0; i < oct; i++) {
        value += amplitude * perlinNoise(st * frequency);
        maxValue += amplitude;
        st += float2(100.0, 100.0); // Shift to avoid artifacts
        frequency *= lac;
        amplitude *= pers;
    }
    return value / maxValue; // Normalize to 0..1
}

// Voronoi noise for interesting terrain features
float voronoi(float2 st, float scale) {
    st *= scale;
    float2 i = floor(st);
    float2 f = frac(st);
    
    float minDist = 8.0;
    
    // Check 3x3 grid around current cell
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            float2 neighbor = float2(float(x), float(y));
            float2 cellPoint = random2(i + neighbor) + neighbor;
            float2 diff = cellPoint - f;
            float dist = length(diff);
            minDist = min(minDist, dist);
        }
    }
    
    return minDist;
}

// Cellular noise (Worley noise)
float cellularNoise(float2 st, float scale) {
    st *= scale;
    float2 i = floor(st);
    float2 f = frac(st);
    
    float minDist1 = 8.0;
    float minDist2 = 8.0;
    
    // Check 3x3 grid
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            float2 neighbor = float2(float(x), float(y));
            float2 cellPoint = random2(i + neighbor) + neighbor;
            float2 diff = cellPoint - f;
            float dist = length(diff);
            
            if (dist < minDist1) {
                minDist2 = minDist1;
                minDist1 = dist;
            } else if (dist < minDist2) {
                minDist2 = dist;
            }
        }
    }
    
    return minDist2 - minDist1; // F1-F2 gives interesting patterns
}

// Ridge noise for mountain peaks
float ridgeNoise(float2 st, int oct, float pers, float lac) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    float maxValue = 0.0;
    
    for (int i = 0; i < oct; i++) {
        float n = perlinNoise(st * frequency);
        n = abs(n * 2.0 - 1.0); // Create ridges
        n = 1.0 - n; // Invert for peaks
        n = n * n; // Sharpen peaks
        value += amplitude * n;
        maxValue += amplitude;
        st += float2(100.0, 100.0);
        frequency *= lac;
        amplitude *= pers;
    }
    return value / maxValue;
}

// Domain warping for more natural features
float2 domainWarp(float2 p, float strength) {
    float2 q = float2(
        fbm(p + float2(0.0, 0.0), 4, 0.5, 2.0),
        fbm(p + float2(5.2, 1.3), 4, 0.5, 2.0)
    );
    return p + q * strength;
}

// River/valley generation using noise
float generateRivers(float2 worldPos) {
    // Create river paths using noise
    float riverNoise = fbm(worldPos * 0.001, 3, 0.5, 2.0);
    
    // Create winding river paths
    float2 riverPos = worldPos * 0.0005;
    float river1 = fbm(riverPos + float2(seed * 100.0, seed * 200.0), 4, 0.4, 2.5);
    float river2 = fbm(riverPos + float2(seed * 300.0, seed * 400.0), 4, 0.4, 2.5);
    
    // Combine rivers
    float riverMask = min(river1, river2);
    riverMask = smoothstep(0.3, 0.5, riverMask); // Create river channels
    
    // Create valleys along rivers
    float valley = 1.0 - riverMask * valleyStrength;
    
    return valley;
}

// Enhanced erosion simulation
float applyErosion(float height, float2 pos, float strength) {
    // Multi-pass erosion simulation
    float2 offset = float2(0.15, 0.15);
    
    // Sample surrounding heights
    float hL = fbm(pos - offset, 3, 0.5, 2.0) * heightMultiplier;
    float hR = fbm(pos + offset, 3, 0.5, 2.0) * heightMultiplier;
    float hD = fbm(pos - float2(0.0, 0.15), 3, 0.5, 2.0) * heightMultiplier;
    float hU = fbm(pos + float2(0.0, 0.15), 3, 0.5, 2.0) * heightMultiplier;
    
    float avgHeight = (hL + hR + hD + hU) * 0.25;
    float slope = abs(height - avgHeight);
    
    // Erode steep slopes more aggressively
    float erosionAmount = strength * 0.15;
    if (slope > 3.0) {
        height = lerp(height, avgHeight, erosionAmount * (slope / 10.0));
    }
    
    return height;
}

float GetHeight(float2 worldPos) {
    float2 noisePos = (worldPos + float2(seed * 100.0, seed * 100.0)) * noiseScale;
    
    // Apply domain warping for more natural features
    float2 warpedPos = domainWarp(noisePos, domainWarpStrength);
    
    // Multi-layer terrain generation
    // Macro scale - large continents and landmasses
    float macroHeight = fbm(warpedPos * macroScale, octaves, persistence, lacunarity) * macroWeight;
    
    // Meso scale - hills and valleys
    float mesoHeight = fbm(warpedPos * mesoScale + float2(seed * 50.0, seed * 50.0), 5, 0.6, 2.0) * mesoWeight;
    
    // Micro scale - fine details
    float microHeight = fbm(warpedPos * microScale + float2(seed * 25.0, seed * 25.0), 3, 0.7, 2.5) * microWeight;
    
    // Combine layers
    float baseHeight = macroHeight + mesoHeight + microHeight;
    baseHeight = saturate(baseHeight); // Clamp to 0-1
    
    // Add Voronoi features for interesting terrain
    float voronoiFeature = voronoi(warpedPos, voronoiScale);
    voronoiFeature = smoothstep(0.2, 0.8, voronoiFeature);
    baseHeight += voronoiFeature * voronoiStrength * 0.3;
    
    // Add cellular noise for texture
    float cellularFeature = cellularNoise(warpedPos, cellularScale);
    baseHeight += cellularFeature * cellularStrength * 0.1;
    
    // Mountain generation using ridge noise
    float2 mountainPos = warpedPos * 0.3; // Larger scale for mountains
    float mountainNoise = ridgeNoise(mountainPos, 8, 0.4, 2.2);
    float mountains = mountainNoise * mountainStrength;
    
    // Combine base terrain with mountains
    float height = baseHeight;
    
    // Add mountains where base height is already high
    if (baseHeight > 0.4) {
        height = lerp(height, height + mountains, smoothstep(0.4, 0.7, baseHeight));
    }
    
    // Create plains (flatten low areas)
    if (baseHeight < 0.3) {
        height = lerp(height, baseHeight * 0.5, plainStrength);
    }
    
    // Generate rivers and valleys
    float riverValley = generateRivers(worldPos);
    height *= riverValley; // Carve valleys
    
    // Apply erosion
    if (erosionStrength > 0.0) {
        height = applyErosion(height * heightMultiplier, warpedPos, erosionStrength) / heightMultiplier;
    }
    
    // Final height
    return height * heightMultiplier;
}

// Enhanced biome system
// 0=Ocean, 1=Beach, 2=Plains, 3=Grassland, 4=Forest, 5=Mountain, 6=Snow, 7=Desert
float GetBiome(float heightNorm, float moisture, float temp) {
    if (heightNorm < 0.15) return 0.0; // Ocean
    if (heightNorm < 0.22) return 1.0; // Beach
    
    if (heightNorm > 0.85) return 6.0; // Snow peaks
    if (heightNorm > 0.65) return 5.0; // Mountains
    
    // Biome based on moisture and temperature
    if (temp > 0.65 && moisture < 0.3) return 7.0; // Desert
    if (moisture > 0.65 && heightNorm < 0.5) return 4.0; // Forest
    if (moisture > 0.4) return 3.0; // Grassland
    if (heightNorm < 0.35) return 2.0; // Plains
    
    return 3.0; // Default to grassland
}

[numthreads(8, 8, 1)]
void GenerateHeightmap (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;

    float step = chunkSize / (float)(resolution - 1);
    float2 localPos = float2(id.x * step, id.y * step);
    float2 worldPos = float2(chunkX * chunkSize, chunkY * chunkSize) + localPos;

    float height = GetHeight(worldPos);
    
    // Moisture & Temp noise with better distribution
    float moisture = fbm((worldPos + seed * 500.0) * moistureNoiseScale, 4, 0.5, 2.0);
    float temp = fbm((worldPos + seed * 800.0) * temperatureNoiseScale, 4, 0.5, 2.0);
    
    // Temperature varies with height (higher = colder)
    float heightNorm = height / heightMultiplier;
    temp = lerp(temp, temp * 0.3, smoothstep(0.3, 0.9, heightNorm));
    
    // Moisture varies with height (valleys = more moisture)
    moisture = lerp(moisture, moisture * 1.2, smoothstep(0.2, 0.4, 1.0 - heightNorm));
    
    float biome = GetBiome(heightNorm, moisture, temp);

    HeightMap[id.xy] = height;
    BiomeMap[id.xy] = float4(biome, moisture, temp, 0.0);
}

[numthreads(8, 8, 1)]
void CalculateNormals (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Finite difference method for normals from HeightMap
    float step = chunkSize / (float)(resolution - 1);
    float hL = HeightMap[int2(max(0, (int)id.x - 1), id.y)];
    float hR = HeightMap[int2(min(resolution - 1, (int)id.x + 1), id.y)];
    float hD = HeightMap[int2(id.x, max(0, (int)id.y - 1))];
    float hU = HeightMap[int2(id.x, min(resolution - 1, (int)id.y + 1))];
    
    float3 n = normalize(float3((hL - hR) / (2.0 * step), 2.0, (hD - hU) / (2.0 * step)));
    Normals[id.x + id.y * resolution] = n;
}


[numthreads(8, 8, 1)]
void GenerateMesh (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    int index = id.x + id.y * resolution;
    float step = chunkSize / (float)(resolution - 1);
    
    float height = HeightMap[id.xy];
    
    Vertices[index] = float3(id.x * step, height, id.y * step);
    UVs[index] = float2(id.x / (float)(resolution - 1), id.y / (float)(resolution - 1));
    
    // Generate Triangles (only for x < res-1 and y < res-1)
    if (id.x < (uint)(resolution - 1) && id.y < (uint)(resolution - 1)) {
        int triIndex = (id.x + id.y * (resolution - 1)) * 6;
        
        Triangles[triIndex] = index;
        Triangles[triIndex + 1] = index + resolution;
        Triangles[triIndex + 2] = index + 1;
        
        Triangles[triIndex + 3] = index + 1;
        Triangles[triIndex + 4] = index + resolution;
        Triangles[triIndex + 5] = index + resolution + 1;
    }
}

[numthreads(8, 8, 1)]
void PlaceVegetation (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)resolution || id.y >= (uint)resolution) return;
    
    // Read cached values
    float height = HeightMap[id.xy];
    float4 biomeData = BiomeMap[id.xy];
    float biome = biomeData.x;
    float moisture = biomeData.y;
    
    // Random check
    float2 worldPos = float2(chunkX * chunkSize + id.x * (chunkSize/resolution), chunkY * chunkSize + id.y * (chunkSize/resolution));
    float rng = random(worldPos * 1.23); // New random seed per pos
    
    float heightNorm = height / heightMultiplier;
    float slope = 1.0 - Normals[id.x + id.y * resolution].y;

    if (heightNorm < 0.22) return; // Underwater/Beach
    if (slope > 0.45) return; // Too steep

    // Spawning logic
    VegetationInstance inst;
    inst.position = Vertices[id.x + id.y * resolution];
    inst.scale = float3(1, 1, 1) * (0.8 + rng * 0.4);
    inst.rotationY = rng * 360.0;
    
    // Forest: Trees
    if (biome == 4.0) { // Forest
        if (rng > 0.97) { // 3% chance per vertex
             inst.typeID = 0; // Tree
             VegetationBuffer.Append(inst);
             return;
        }
    }
    
    // Grassland: Some trees and grass
    if (biome == 3.0) {
        if (rng > 0.995) { // 0.5% chance for trees
            inst.typeID = 0; // Tree
            VegetationBuffer.Append(inst);
            return;
        }
    }
    
    // Everywhere suitable: Grass
    if (biome == 2.0 || biome == 3.0 || biome == 4.0) { // Plains, Grassland, Forest
        if (rng > 0.75 && rng < 0.92) { // 17% chance
            inst.typeID = 2; // Grass
            // Slightly randomize position off-grid
            inst.position.x += (rng - 0.5) * 2.0;
            inst.position.z += (random(worldPos*2.0) - 0.5) * 2.0;
            VegetationBuffer.Append(inst);
        }
    }
    
    // Mountains: Rocks
    if (biome == 5.0 || biome == 6.0 || slope > 0.25) { // Mountain, Snow, or steep
         if (rng > 0.98) { // 2% chance
             inst.typeID = 1; // Rock
             inst.scale = float3(1, 1, 1) * (0.5 + rng * 1.0); // Vary rock size more
             VegetationBuffer.Append(inst);
         }
    }
}
